<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Talking Terrence - Head Flap Studio Demo</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a0f; min-height: 100vh; }
    #root { min-height: 100vh; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script>
    const { useState, useRef, useEffect, createElement: h } = React;

    const STAGES = { SETUP: 'setup', CUT_LINE: 'cutLine', DUBBING: 'dubbing' };

    function TalkingTerrence() {
      const [stage, setStage] = useState(STAGES.SETUP);
      const [background, setBackground] = useState(null);
      const [backgroundImg, setBackgroundImg] = useState(null);
      const [character, setCharacter] = useState(null);
      const [characterImg, setCharacterImg] = useState(null);
      const [charTransform, setCharTransform] = useState({ x: 400, y: 280, scale: 1, rotation: 0 });
      const [cutLine, setCutLine] = useState({ start: null, end: null });
      const [isDrawing, setIsDrawing] = useState(false);
      const [pivotSide, setPivotSide] = useState('left');
      const [mouthOpen, setMouthOpen] = useState(0);
      const [isPlaying, setIsPlaying] = useState(false);
      const [sensitivity, setSensitivity] = useState(2);
      const [maxAngle, setMaxAngle] = useState(35);
      const [audioData, setAudioData] = useState(null);
      const [inputMode, setInputMode] = useState('manual');
      const [isSpaceHeld, setIsSpaceHeld] = useState(false);
      
      const canvasRef = useRef(null);
      const animationFrameRef = useRef(null);
      const audioRef = useRef(null);
      const audioContextRef = useRef(null);
      const analyserRef = useRef(null);
      
      const cutLineRef = useRef(cutLine);
      const mouthOpenRef = useRef(mouthOpen);
      const stageRef = useRef(stage);
      const pivotSideRef = useRef(pivotSide);
      const maxAngleRef = useRef(maxAngle);
      const charTransformRef = useRef(charTransform);
      
      useEffect(function() { cutLineRef.current = cutLine; }, [cutLine]);
      useEffect(function() { mouthOpenRef.current = mouthOpen; }, [mouthOpen]);
      useEffect(function() { stageRef.current = stage; }, [stage]);
      useEffect(function() { pivotSideRef.current = pivotSide; }, [pivotSide]);
      useEffect(function() { maxAngleRef.current = maxAngle; }, [maxAngle]);
      useEffect(function() { charTransformRef.current = charTransform; }, [charTransform]);

      useEffect(function() {
        if (background) {
          var img = new Image();
          img.onload = function() { setBackgroundImg(img); };
          img.src = background;
        } else {
          setBackgroundImg(null);
        }
      }, [background]);

      useEffect(function() {
        if (character) {
          var img = new Image();
          img.onload = function() { setCharacterImg(img); };
          img.src = character;
        } else {
          setCharacterImg(null);
        }
      }, [character]);

      useEffect(function() {
        if (stage !== STAGES.DUBBING || inputMode !== 'keyboard') return;
        
        function handleKeyDown(e) {
          if (e.code === 'Space' && !e.repeat) {
            e.preventDefault();
            setIsSpaceHeld(true);
          }
        }
        
        function handleKeyUp(e) {
          if (e.code === 'Space') {
            e.preventDefault();
            setIsSpaceHeld(false);
          }
        }
        
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        
        return function() {
          window.removeEventListener('keydown', handleKeyDown);
          window.removeEventListener('keyup', handleKeyUp);
        };
      }, [stage, inputMode]);

      useEffect(function() {
        if (inputMode === 'keyboard') {
          setMouthOpen(isSpaceHeld ? 1 : 0);
        }
      }, [isSpaceHeld, inputMode]);

      useEffect(function() {
        var canvas = canvasRef.current;
        if (!canvas) return;
        var ctx = canvas.getContext('2d');
        
        var frameId;
        
        function render() {
          var currentCutLine = cutLineRef.current;
          var currentMouthOpen = mouthOpenRef.current;
          var currentStage = stageRef.current;
          var currentPivotSide = pivotSideRef.current;
          var currentMaxAngle = maxAngleRef.current;
          var currentCharTransform = charTransformRef.current;
          
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          if (backgroundImg) {
            ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
          } else {
            var grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, '#2d5a27');
            grad.addColorStop(1, '#1a3d15');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#3d2914';
            ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
          }
          
          if (characterImg) {
            var x = currentCharTransform.x;
            var y = currentCharTransform.y;
            var scale = currentCharTransform.scale;
            var rotation = currentCharTransform.rotation;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate((rotation * Math.PI) / 180);
            
            if (currentStage === STAGES.DUBBING && currentCutLine.start && currentCutLine.end) {
              drawAnimatedCharacter(ctx, characterImg, scale, currentCutLine, currentCharTransform, currentPivotSide, currentMouthOpen, currentMaxAngle);
            } else {
              ctx.scale(scale, scale);
              ctx.drawImage(characterImg, -characterImg.width / 2, -characterImg.height / 2);
            }
            
            ctx.restore();
          }
          
          if (currentStage === STAGES.CUT_LINE && currentCutLine.start) {
            ctx.save();
            ctx.strokeStyle = '#ff0066';
            ctx.lineWidth = 4;
            ctx.setLineDash([8, 6]);
            ctx.lineDashOffset = -Date.now() / 50;
            ctx.beginPath();
            ctx.moveTo(currentCutLine.start.x, currentCutLine.start.y);
            if (currentCutLine.end) {
              ctx.lineTo(currentCutLine.end.x, currentCutLine.end.y);
            }
            ctx.stroke();
            
            if (currentCutLine.end) {
              ctx.fillStyle = currentPivotSide === 'left' ? '#00ff88' : '#ff6b6b';
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 2;
              ctx.setLineDash([]);
              ctx.beginPath();
              ctx.arc(currentCutLine.start.x, currentCutLine.start.y, 10, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
              
              ctx.fillStyle = currentPivotSide === 'right' ? '#00ff88' : '#ff6b6b';
              ctx.beginPath();
              ctx.arc(currentCutLine.end.x, currentCutLine.end.y, 10, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
              
              var pivotPoint = currentPivotSide === 'left' ? currentCutLine.start : currentCutLine.end;
              ctx.strokeStyle = '#00ff88';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pivotPoint.x, pivotPoint.y, 16, 0, Math.PI * 2);
              ctx.stroke();
            }
            ctx.restore();
          }
          
          frameId = requestAnimationFrame(render);
        }
        
        render();
        
        return function() {
          if (frameId) cancelAnimationFrame(frameId);
        };
      }, [backgroundImg, characterImg]);

      function drawAnimatedCharacter(ctx, img, scale, currentCutLine, currentCharTransform, currentPivotSide, currentMouthOpen, currentMaxAngle) {
        if (!currentCutLine.start || !currentCutLine.end) return;
        
        var x = currentCharTransform.x;
        var y = currentCharTransform.y;
        var imgW = img.width;
        var imgH = img.height;
        
        var localStart = {
          x: (currentCutLine.start.x - x) / scale + imgW / 2,
          y: (currentCutLine.start.y - y) / scale + imgH / 2
        };
        var localEnd = {
          x: (currentCutLine.end.x - x) / scale + imgW / 2,
          y: (currentCutLine.end.y - y) / scale + imgH / 2
        };
        
        var cutY = Math.min(localStart.y, localEnd.y);
        
        ctx.scale(scale, scale);
        
        ctx.save();
        ctx.beginPath();
        ctx.rect(-imgW / 2, cutY - imgH / 2, imgW, imgH);
        ctx.clip();
        ctx.drawImage(img, -imgW / 2, -imgH / 2);
        ctx.restore();
        
        var pivot = currentPivotSide === 'left' ? localStart : localEnd;
        var pivotX = pivot.x - imgW / 2;
        var pivotY = pivot.y - imgH / 2;
        
        var rotationDir = currentPivotSide === 'left' ? -1 : 1;
        var currentAngle = (currentMouthOpen * currentMaxAngle * rotationDir * Math.PI) / 180;
        
        ctx.save();
        ctx.translate(pivotX, pivotY);
        ctx.rotate(currentAngle);
        ctx.translate(-pivotX, -pivotY);
        
        ctx.beginPath();
        ctx.rect(-imgW / 2, -imgH / 2, imgW, cutY);
        ctx.clip();
        ctx.drawImage(img, -imgW / 2, -imgH / 2);
        ctx.restore();
      }

      function handleFileUpload(e, type) {
        var file = e.target.files[0];
        if (!file) return;
        
        if (type === 'audio') {
          var url = URL.createObjectURL(file);
          setAudioData(url);
          return;
        }
        
        var reader = new FileReader();
        reader.onload = function(ev) {
          if (type === 'background') {
            setBackground(ev.target.result);
          } else {
            setCharacter(ev.target.result);
          }
        };
        reader.readAsDataURL(file);
      }

      function getCanvasCoords(e) {
        var canvas = canvasRef.current;
        var rect = canvas.getBoundingClientRect();
        var scaleX = canvas.width / rect.width;
        var scaleY = canvas.height / rect.height;
        return {
          x: (e.clientX - rect.left) * scaleX,
          y: (e.clientY - rect.top) * scaleY
        };
      }

      function handleCanvasMouseDown(e) {
        if (stage !== STAGES.CUT_LINE) return;
        e.preventDefault();
        var coords = getCanvasCoords(e);
        var newCutLine = { start: coords, end: null };
        setCutLine(newCutLine);
        cutLineRef.current = newCutLine;
        setIsDrawing(true);
      }

      function handleCanvasMouseMove(e) {
        if (!isDrawing || stage !== STAGES.CUT_LINE) return;
        e.preventDefault();
        var coords = getCanvasCoords(e);
        var newCutLine = { start: cutLineRef.current.start, end: coords };
        setCutLine(newCutLine);
        cutLineRef.current = newCutLine;
      }

      function handleCanvasMouseUp(e) {
        if (isDrawing) {
          if (e) e.preventDefault();
          setIsDrawing(false);
        }
      }

      function playAudio() {
        if (!audioData || !audioRef.current) return;
        
        if (!audioContextRef.current) {
          audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
          analyserRef.current = audioContextRef.current.createAnalyser();
          analyserRef.current.fftSize = 256;
          
          var source = audioContextRef.current.createMediaElementSource(audioRef.current);
          source.connect(analyserRef.current);
          analyserRef.current.connect(audioContextRef.current.destination);
        }
        
        audioRef.current.play();
        setIsPlaying(true);
        analyzeAudio();
      }

      function stopAudio() {
        if (audioRef.current) {
          audioRef.current.pause();
          audioRef.current.currentTime = 0;
        }
        setIsPlaying(false);
        setMouthOpen(0);
        if (animationFrameRef.current) {
          cancelAnimationFrame(animationFrameRef.current);
        }
      }

      function analyzeAudio() {
        if (!analyserRef.current || !audioRef.current) return;
        
        var dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
        
        function analyze() {
          if (audioRef.current.paused || audioRef.current.ended) {
            setIsPlaying(false);
            setMouthOpen(0);
            return;
          }
          
          analyserRef.current.getByteFrequencyData(dataArray);
          
          var sum = 0;
          var startBin = Math.floor(300 / (audioContextRef.current.sampleRate / analyserRef.current.fftSize));
          var endBin = Math.min(dataArray.length, Math.floor(3000 / (audioContextRef.current.sampleRate / analyserRef.current.fftSize)));
          
          for (var i = startBin; i < endBin; i++) {
            sum += dataArray[i];
          }
          var avg = sum / (endBin - startBin);
          
          var normalized = Math.min(1, (avg / 128) * sensitivity);
          var threshold = 0.08;
          var openAmount = normalized > threshold ? Math.pow(normalized, 0.7) : 0;
          
          setMouthOpen(openAmount);
          mouthOpenRef.current = openAmount;
          
          animationFrameRef.current = requestAnimationFrame(analyze);
        }
        
        analyze();
      }

      function proceedToNextStage() {
        if (stage === STAGES.SETUP && characterImg) {
          setStage(STAGES.CUT_LINE);
        } else if (stage === STAGES.CUT_LINE && cutLine.start && cutLine.end) {
          setStage(STAGES.DUBBING);
        }
      }

      function goBack() {
        if (stage === STAGES.DUBBING) {
          stopAudio();
          setStage(STAGES.CUT_LINE);
        } else if (stage === STAGES.CUT_LINE) {
          var emptyCutLine = { start: null, end: null };
          setCutLine(emptyCutLine);
          cutLineRef.current = emptyCutLine;
          setStage(STAGES.SETUP);
        }
      }

      var S = {
        container: { minHeight: '100vh', background: '#0a0a0f', padding: '16px', fontFamily: 'system-ui, -apple-system, sans-serif', color: '#fff' },
        header: { textAlign: 'center', marginBottom: '16px' },
        title: { margin: '0 0 12px 0', display: 'flex', flexDirection: 'column', gap: '4px' },
        titleAccent: { fontSize: '24px', fontWeight: 800, color: '#00ff88', textShadow: '0 0 20px rgba(0,255,136,0.5)', letterSpacing: '3px' },
        subtitle: { fontSize: '14px', color: '#666', fontWeight: 400, letterSpacing: '6px', textTransform: 'uppercase' },
        stageIndicator: { display: 'flex', justifyContent: 'center', gap: '8px' },
        stageStep: { display: 'flex', alignItems: 'center', gap: '8px', padding: '8px 16px', borderRadius: '20px', border: '2px solid', fontSize: '12px', fontWeight: 600, transition: 'all 0.3s' },
        stageNum: { width: '20px', height: '20px', borderRadius: '50%', background: 'rgba(0,0,0,0.3)', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '11px' },
        stageLabel: { letterSpacing: '1px' },
        workspace: { display: 'flex', justifyContent: 'center', alignItems: 'flex-start', gap: '12px', marginBottom: '16px' },
        canvas: { border: '3px solid #ff0066', borderRadius: '8px', boxShadow: '0 0 40px rgba(255,0,102,0.2)', cursor: 'crosshair', maxWidth: '100%', height: 'auto' },
        volumeMeter: { width: '40px', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '8px' },
        volumeLabel: { fontSize: '10px', color: '#666', letterSpacing: '2px' },
        volumeTrack: { width: '24px', height: '200px', background: '#1a1a1a', borderRadius: '12px', border: '2px solid #333', position: 'relative', overflow: 'hidden' },
        volumeBar: { position: 'absolute', bottom: 0, left: 0, right: 0, background: 'linear-gradient(to top, #00ff88, #88ff00, #ffff00, #ff8800, #ff0066)', borderRadius: '10px', transition: 'height 0.05s ease-out' },
        volumeValue: { fontSize: '11px', color: '#00ff88', fontWeight: 600 },
        controls: { maxWidth: '820px', margin: '0 auto', padding: '20px', background: 'rgba(20,20,25,0.8)', borderRadius: '12px', border: '1px solid #222' },
        setupPanel: { display: 'flex', flexDirection: 'column', gap: '20px' },
        uploadSection: { display: 'flex', justifyContent: 'center', gap: '16px', flexWrap: 'wrap' },
        uploadBtn: { padding: '20px 28px', background: '#151518', border: '2px dashed #ff0066', borderRadius: '12px', color: '#fff', cursor: 'pointer', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '8px', transition: 'all 0.2s', minWidth: '160px' },
        uploadIcon: { fontSize: '28px' },
        uploadHint: { fontSize: '10px', color: '#555' },
        hiddenInput: { display: 'none' },
        transformControls: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))', gap: '16px', padding: '16px', background: '#111', borderRadius: '8px' },
        sliderGroup: { display: 'flex', flexDirection: 'column', gap: '6px' },
        sliderLabel: { fontSize: '11px', color: '#888', textTransform: 'uppercase', letterSpacing: '1px' },
        slider: { width: '100%', accentColor: '#ff0066', cursor: 'pointer', height: '6px' },
        cutLinePanel: { textAlign: 'center' },
        instruction: { fontSize: '14px', lineHeight: 1.6, color: '#aaa', marginBottom: '20px' },
        pivotSelector: { display: 'flex', justifyContent: 'center', alignItems: 'center', gap: '12px', marginBottom: '16px' },
        pivotLabel: { fontSize: '12px', color: '#666', letterSpacing: '1px' },
        pivotBtn: { padding: '10px 20px', border: '2px solid #00ff88', borderRadius: '6px', fontSize: '12px', fontWeight: 600, cursor: 'pointer', transition: 'all 0.2s', fontFamily: 'inherit' },
        helpText: { fontSize: '12px', color: '#666', marginTop: '8px' },
        dubbingPanel: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '20px' },
        modeSelector: { display: 'flex', gap: '8px' },
        modeBtn: { padding: '12px 20px', border: '2px solid #ff0066', borderRadius: '8px', color: '#fff', fontSize: '12px', fontWeight: 600, cursor: 'pointer', transition: 'all 0.2s', fontFamily: 'inherit' },
        manualControls: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '8px', padding: '20px', background: '#111', borderRadius: '8px', width: '100%', maxWidth: '400px' },
        keyboardInfo: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '12px', padding: '20px' },
        spaceKey: { padding: '16px 48px', borderRadius: '8px', fontSize: '14px', fontWeight: 700, letterSpacing: '2px', border: '3px solid #555', boxShadow: '0 4px 0 #222', transition: 'all 0.1s' },
        audioControls: { display: 'flex', alignItems: 'center', gap: '16px', flexWrap: 'wrap', justifyContent: 'center' },
        audioUploadBtn: { padding: '12px 24px', background: '#222', border: '2px solid #555', borderRadius: '8px', color: '#fff', fontSize: '12px', cursor: 'pointer', fontWeight: 600 },
        playBtn: { padding: '14px 32px', border: 'none', borderRadius: '8px', color: '#000', fontSize: '14px', fontWeight: 700, cursor: 'pointer', fontFamily: 'inherit' },
        dubbingSettings: { display: 'flex', gap: '24px', padding: '16px', background: '#111', borderRadius: '8px' },
        navButtons: { display: 'flex', justifyContent: 'center', gap: '16px', marginTop: '20px' },
        backBtn: { padding: '12px 28px', background: 'transparent', border: '2px solid #444', borderRadius: '8px', color: '#888', fontSize: '12px', fontWeight: 600, cursor: 'pointer', fontFamily: 'inherit' },
        nextBtn: { padding: '12px 28px', background: 'linear-gradient(135deg, #ff0066 0%, #ff4488 100%)', border: 'none', borderRadius: '8px', color: '#fff', fontSize: '12px', fontWeight: 600, cursor: 'pointer', fontFamily: 'inherit', boxShadow: '0 4px 15px rgba(255,0,102,0.3)' }
      };

      var stageData = [
        { key: STAGES.SETUP, label: 'SETUP' },
        { key: STAGES.CUT_LINE, label: 'CUT' },
        { key: STAGES.DUBBING, label: 'DUB' }
      ];

      return h('div', { style: S.container },
        h('div', { style: S.header },
          h('h1', { style: S.title },
            h('span', { style: S.titleAccent }, 'TERRANCE & PHILLIP'),
            h('span', { style: S.subtitle }, 'Head Flap Studio')
          ),
          h('div', { style: S.stageIndicator },
            stageData.map(function(s, i) {
              return h('div', {
                key: s.key,
                style: Object.assign({}, S.stageStep, {
                  background: stage === s.key ? '#00ff88' : '#333',
                  color: stage === s.key ? '#000' : '#666',
                  borderColor: stage === s.key ? '#00ff88' : '#444'
                })
              },
                h('span', { style: S.stageNum }, i + 1),
                h('span', { style: S.stageLabel }, s.label)
              );
            })
          )
        ),

        h('div', { style: S.workspace },
          h('canvas', {
            ref: canvasRef,
            width: 800,
            height: 500,
            style: S.canvas,
            onMouseDown: handleCanvasMouseDown,
            onMouseMove: handleCanvasMouseMove,
            onMouseUp: handleCanvasMouseUp,
            onMouseLeave: handleCanvasMouseUp
          }),
          stage === STAGES.DUBBING ? h('div', { style: S.volumeMeter },
            h('div', { style: S.volumeLabel }, 'FLAP'),
            h('div', { style: S.volumeTrack },
              h('div', { style: Object.assign({}, S.volumeBar, { height: (mouthOpen * 100) + '%' }) })
            ),
            h('div', { style: S.volumeValue }, Math.round(mouthOpen * 100) + '%')
          ) : null
        ),

        h('div', { style: S.controls },
          stage === STAGES.SETUP ? h('div', { style: S.setupPanel },
            h('div', { style: S.uploadSection },
              h('label', { style: S.uploadBtn },
                h('span', { style: S.uploadIcon }, 'üñºÔ∏è'),
                h('span', null, 'BACKGROUND'),
                h('span', { style: S.uploadHint }, '(optional)'),
                h('input', { type: 'file', accept: 'image/*', onChange: function(e) { handleFileUpload(e, 'background'); }, style: S.hiddenInput })
              ),
              h('label', { style: Object.assign({}, S.uploadBtn, { borderColor: characterImg ? '#00ff88' : '#ff0066' }) },
                h('span', { style: S.uploadIcon }, 'üßç'),
                h('span', null, 'CHARACTER'),
                h('span', { style: S.uploadHint }, '(transparent PNG)'),
                h('input', { type: 'file', accept: 'image/png', onChange: function(e) { handleFileUpload(e, 'character'); }, style: S.hiddenInput })
              )
            ),
            characterImg ? h('div', { style: S.transformControls },
              h('div', { style: S.sliderGroup },
                h('label', { style: S.sliderLabel }, 'X Position'),
                h('input', { type: 'range', min: 0, max: 800, value: charTransform.x, onChange: function(e) { setCharTransform(function(p) { return Object.assign({}, p, { x: Number(e.target.value) }); }); }, style: S.slider })
              ),
              h('div', { style: S.sliderGroup },
                h('label', { style: S.sliderLabel }, 'Y Position'),
                h('input', { type: 'range', min: 0, max: 500, value: charTransform.y, onChange: function(e) { setCharTransform(function(p) { return Object.assign({}, p, { y: Number(e.target.value) }); }); }, style: S.slider })
              ),
              h('div', { style: S.sliderGroup },
                h('label', { style: S.sliderLabel }, 'Scale: ' + charTransform.scale.toFixed(1) + 'x'),
                h('input', { type: 'range', min: 0.1, max: 3, step: 0.1, value: charTransform.scale, onChange: function(e) { setCharTransform(function(p) { return Object.assign({}, p, { scale: Number(e.target.value) }); }); }, style: S.slider })
              ),
              h('div', { style: S.sliderGroup },
                h('label', { style: S.sliderLabel }, 'Rotation: ' + charTransform.rotation + '¬∞'),
                h('input', { type: 'range', min: -45, max: 45, value: charTransform.rotation, onChange: function(e) { setCharTransform(function(p) { return Object.assign({}, p, { rotation: Number(e.target.value) }); }); }, style: S.slider })
              )
            ) : null
          ) : null,

          stage === STAGES.CUT_LINE ? h('div', { style: S.cutLinePanel },
            h('p', { style: S.instruction },
              'Draw a line across the jaw where the head should split.',
              h('br'),
              'Click + drag from one side to the other.'
            ),
            h('div', { style: S.pivotSelector },
              h('span', { style: S.pivotLabel }, 'HINGE SIDE:'),
              h('button', {
                style: Object.assign({}, S.pivotBtn, { background: pivotSide === 'left' ? '#00ff88' : '#222', color: pivotSide === 'left' ? '#000' : '#888' }),
                onClick: function() { setPivotSide('left'); }
              }, '‚óÄ LEFT'),
              h('button', {
                style: Object.assign({}, S.pivotBtn, { background: pivotSide === 'right' ? '#00ff88' : '#222', color: pivotSide === 'right' ? '#000' : '#888' }),
                onClick: function() { setPivotSide('right'); }
              }, 'RIGHT ‚ñ∂')
            ),
            (cutLine.start && cutLine.end) ? h('p', { style: S.helpText },
              h('span', { style: { color: '#00ff88' } }, '‚óè'), ' Green = hinge point  ',
              h('span', { style: { color: '#ff6b6b' } }, '‚óè'), ' Red = free end'
            ) : null
          ) : null,

          stage === STAGES.DUBBING ? h('div', { style: S.dubbingPanel },
            h('div', { style: S.modeSelector },
              h('button', {
                style: Object.assign({}, S.modeBtn, { background: inputMode === 'manual' ? '#ff0066' : '#222' }),
                onClick: function() { setInputMode('manual'); stopAudio(); }
              }, 'üéöÔ∏è MANUAL'),
              h('button', {
                style: Object.assign({}, S.modeBtn, { background: inputMode === 'keyboard' ? '#ff0066' : '#222' }),
                onClick: function() { setInputMode('keyboard'); stopAudio(); }
              }, '‚å®Ô∏è KEYBOARD'),
              h('button', {
                style: Object.assign({}, S.modeBtn, { background: inputMode === 'audio' ? '#ff0066' : '#222' }),
                onClick: function() { setInputMode('audio'); }
              }, 'üîä AUDIO FILE')
            ),

            inputMode === 'manual' ? h('div', { style: S.manualControls },
              h('label', { style: S.sliderLabel }, 'Mouth Open: ' + Math.round(mouthOpen * 100) + '%'),
              h('input', {
                type: 'range', min: 0, max: 1, step: 0.01, value: mouthOpen,
                onChange: function(e) { setMouthOpen(Number(e.target.value)); mouthOpenRef.current = Number(e.target.value); },
                style: Object.assign({}, S.slider, { width: '300px' })
              })
            ) : null,

            inputMode === 'keyboard' ? h('div', { style: S.keyboardInfo },
              h('div', {
                style: Object.assign({}, S.spaceKey, { background: isSpaceHeld ? '#00ff88' : '#333', color: isSpaceHeld ? '#000' : '#fff' })
              }, 'SPACEBAR'),
              h('p', { style: S.helpText }, 'Hold SPACEBAR to open mouth')
            ) : null,

            inputMode === 'audio' ? h('div', { style: S.audioControls },
              h('label', { style: S.audioUploadBtn },
                'üìÅ LOAD AUDIO FILE',
                h('input', { type: 'file', accept: 'audio/*', onChange: function(e) { handleFileUpload(e, 'audio'); }, style: S.hiddenInput })
              ),
              audioData ? h('audio', {
                ref: audioRef,
                src: audioData,
                onEnded: function() { setIsPlaying(false); setMouthOpen(0); }
              }) : null,
              audioData ? h('button', {
                style: Object.assign({}, S.playBtn, { background: isPlaying ? '#ff0066' : '#00ff88' }),
                onClick: isPlaying ? stopAudio : playAudio
              }, isPlaying ? '‚èπ STOP' : '‚ñ∂ PLAY') : null
            ) : null,

            h('div', { style: S.dubbingSettings },
              h('div', { style: S.sliderGroup },
                h('label', { style: S.sliderLabel }, 'Sensitivity: ' + sensitivity.toFixed(1) + 'x'),
                h('input', { type: 'range', min: 0.5, max: 5, step: 0.1, value: sensitivity, onChange: function(e) { setSensitivity(Number(e.target.value)); }, style: S.slider })
              ),
              h('div', { style: S.sliderGroup },
                h('label', { style: S.sliderLabel }, 'Max Angle: ' + maxAngle + '¬∞'),
                h('input', { type: 'range', min: 10, max: 90, value: maxAngle, onChange: function(e) { setMaxAngle(Number(e.target.value)); }, style: S.slider })
              )
            )
          ) : null,

          h('div', { style: S.navButtons },
            stage !== STAGES.SETUP ? h('button', { style: S.backBtn, onClick: goBack }, '‚Üê BACK') : null,
            stage !== STAGES.DUBBING ? h('button', {
              style: Object.assign({}, S.nextBtn, {
                opacity: (stage === STAGES.SETUP && !characterImg) || (stage === STAGES.CUT_LINE && (!cutLine.start || !cutLine.end)) ? 0.4 : 1
              }),
              onClick: proceedToNextStage,
              disabled: (stage === STAGES.SETUP && !characterImg) || (stage === STAGES.CUT_LINE && (!cutLine.start || !cutLine.end))
            }, stage === STAGES.SETUP ? 'DRAW CUT LINE ‚Üí' : 'START DUBBING ‚Üí') : null
          )
        ),

        h('footer', { style: { textAlign: 'center', marginTop: '24px', color: '#444', fontSize: '12px' } },
          h('p', null, 'Talking Terrence JSX - Head Flap Animation Studio'),
          h('p', null, 'Inspired by Terrance & Phillip from South Park'),
          h('a', { href: 'https://github.com/MushroomFleet/talking-terrence-jsx', style: { color: '#ff0066' } }, 'GitHub Repository')
        )
      );
    }

    var root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(TalkingTerrence));
  </script>
</body>
</html>
